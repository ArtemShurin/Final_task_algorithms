## Итоговая работа по дисциплине "Алгоритмы и структуры данных"
## Выполнил Воробьев Артем Константинович, "Разработка IT-продукта"

### Описание основных модулей программы:

'''bash
parse_input(filename)
'''
Вход: Имя файла (input.txt)

Выход: Кортеж (cities, roads, requests)

Метод читает файл построчно, определяет секции: [CITIES], [ROADS], [REQUESTS] и парсит данные каждой секции:

- CITIES: ID: Название_города → словарь {название: id}
- ROADS: ID1 - ID2: длина, время, стоимость → список кортежей
- REQUESTS: Город1 -> Город2 | (приоритеты) → список запросов

2) build_graph(roads)
Вход: Список дорог [(id1, id2, длина, время, стоимость), ...]

Выход: Граф {id_города: [(сосед, длина, время, стоимость), ...]}

Метод создает словарь списков смежности, для каждой дороги добавляет два направления (дороги двусторонние) и оптимизирует структуру для быстрого доступа к соседям.



2) build_graph(roads)
Вход: Список дорог [(id1, id2, длина, время, стоимость), ...]

Выход: Граф {id_города: [(сосед, длина, время, стоимость), ...]}

Метод создает словарь списков смежности, для каждой дороги добавляет два направления (дороги двусторонние) и оптимизирует структуру для быстрого доступа к соседям.

3) dijkstra_with_full_priority(graph, start, target, main_criterion)
Вход:
- Граф
- ID начального и конечного городов
- Индекс критерия (0=длина, 1=время, 2=стоимость)

Выход: Кортеж (путь, сумма_длина, сумма_время, сумма_стоимость, расстояние)

Метод инициализирует расстояния (inf) и предыдущие вершины, использует очередь с приоритетами для выбора следующей вершины и обновляет расстояния до соседей по выбранному критерию. Затем восстанавливает путь от конечной к начальной вершине и вычисляет суммарные параметры найденного пути.
Также при равенстве главного критерия сравнивает по второстепенным и обеспечивает выбор оптимального пути при неоднозначности.

4) find_best_route_by_criteria(graph, start_id, target_id, criterion_idx, id_to_name)
Вход:
Граф, ID городов
Индекс критерия
Словарь преобразования id → название

Выход: Словарь с описанием маршрута или None

Метод вызывает dijkstra для поиска пути, преобразует ID городов в названия и формирует словарь результата:
{
    'path': ['Москва','СПб'],
    'length': 700,
    'time': 480,
    'cost': 800
}

5) get_route_string(route, criterion_name)
Вход:
Словарь маршрута (или None)
Название критерия ('ДЛИНА', 'ВРЕМЯ', 'СТОИМОСТЬ')

Выход: Форматированная строка

Метод возвращает "КРИТЕРИЙ: Маршрут не найден", если маршрут None. Преобразует список городов в строку через " → " и форматирует все параметры маршрута.

6) find_compromise_route(best_routes, priorities, id_to_name, graph, start_id, target_id)
Вход:
Список 3-х оптимальных маршрутов (по каждому критерию)
Список приоритетов ['Д','В','С']
Дополнительные параметры графа

Выход: Словарь лучшего компромиссного маршрута

Метод фильтрует несуществующие маршруты и определяет порядок сравнения по приоритетам. Затем сортирует маршруты: сначала по 1-му приоритету, затем по 2-му, затем по 3-му и возвращает маршрут с минимальными значениями по приоритетам.

7) find_all_routes_dfs(graph, start, target, visited, path, all_routes, ...)
Вход: Граф, параметры поиска, ограничение на количество

Выход: Заполняет список all_routes

Метод выполняет рекурсивный обход графа в глубину, сохраняя все найденные пути до цели, учитывая суммарные параметры каждого пути и ограничивая количество маршрутов для избежания экспоненциального роста.

9) main(), главная функция программы

- Читает входные данные через parse_input
- Строит граф через build_graph
- Для каждого запроса из [REQUESTS]:
- Находит 3 оптимальных маршрута через find_best_route_by_criteria
- Форматирует их через get_route_string
- Находит компромиссный маршрут через find_compromise_route
- Записывает результаты в файл
- Выводит результаты в консоль
